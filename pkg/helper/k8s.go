package helper

import (
    "context"
    "fmt"
    "sort"
    "strings"

    "github.com/openshift-hyperfleet/hyperfleet-e2e/pkg/logger"
    appsv1 "k8s.io/api/apps/v1"
    batchv1 "k8s.io/api/batch/v1"
    corev1 "k8s.io/api/core/v1"
    apierrors "k8s.io/apimachinery/pkg/api/errors"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/apimachinery/pkg/labels"
)

// VerifyNamespaceActive verifies a namespace exists and is in Active phase
func (h *Helper) VerifyNamespaceActive(ctx context.Context, name string, expectedLabels, expectedAnnotations map[string]string) error {
    logger.Info("verifying namespace status", "namespace", name)

    // Get namespace using client-go
    ns, err := h.K8sClient.CoreV1().Namespaces().Get(ctx, name, metav1.GetOptions{})
    if err != nil {
        if apierrors.IsNotFound(err) {
            return fmt.Errorf("namespace %s not found", name)
        }
        return fmt.Errorf("failed to get namespace %s: %w", name, err)
    }

    // Verify phase
    if ns.Status.Phase != corev1.NamespaceActive {
        return fmt.Errorf("namespace %s phase is %v, expected Active", name, ns.Status.Phase)
    }

    // Verify labels
    if err := verifyMapContains(ns.Labels, expectedLabels, "label"); err != nil {
        return fmt.Errorf("namespace %s: %w", name, err)
    }

    // Verify annotations
    if err := verifyMapContains(ns.Annotations, expectedAnnotations, "annotation"); err != nil {
        return fmt.Errorf("namespace %s: %w", name, err)
    }

    logger.Info("namespace verified successfully", "namespace", name, "phase", ns.Status.Phase)
    return nil
}

// VerifyJobComplete verifies a job exists and has completed successfully.
// Uses expectedLabels to find the job via label selector - if the list returns a job,
// it's guaranteed to have those labels (no need to verify them again).
func (h *Helper) VerifyJobComplete(ctx context.Context, namespace string, expectedLabels, expectedAnnotations map[string]string) error {
    // Build label selector from expected labels to find the job
    labelSelector := labels.SelectorFromSet(expectedLabels).String()
    logger.Info("verifying job status", "namespace", namespace, "label_selector", labelSelector)

    // List jobs by label selector
    jobs, err := h.K8sClient.BatchV1().Jobs(namespace).List(ctx, metav1.ListOptions{
        LabelSelector: labelSelector,
    })
    if err != nil {
        if apierrors.IsNotFound(err) {
            return fmt.Errorf("no job found in namespace %s with selector %s", namespace, labelSelector)
        }
        return fmt.Errorf("failed to list jobs in namespace %s with selector %s: %w",
            namespace, labelSelector, err)
    }

    // Verify exactly one job
    if len(jobs.Items) == 0 {
        return fmt.Errorf("no job found in namespace %s with selector %s", namespace, labelSelector)
    }
    if len(jobs.Items) > 1 {
        return fmt.Errorf("multiple jobs (%d) found in namespace %s with selector %s - expected exactly one",
            len(jobs.Items), namespace, labelSelector)
    }

    job := jobs.Items[0]

    // Check completion using JobComplete condition (canonical way)
    var jobComplete bool
    for _, cond := range job.Status.Conditions {
        if cond.Type == batchv1.JobComplete && cond.Status == corev1.ConditionTrue {
            jobComplete = true
            break
        }
    }

    if !jobComplete {
        return fmt.Errorf("job %s in namespace %s has not completed successfully (conditions: %+v)",
            job.Name, namespace, job.Status.Conditions)
    }

    // Verify annotations
    if err := verifyMapContains(job.Annotations, expectedAnnotations, "annotation"); err != nil {
        return fmt.Errorf("job %s in namespace %s: %w", job.Name, namespace, err)
    }

    logger.Info("job verified successfully",
        "namespace", namespace,
        "job", job.Name,
        "succeeded", job.Status.Succeeded,
        "active", job.Status.Active,
        "failed", job.Status.Failed)
    return nil
}

// VerifyDeploymentAvailable verifies a deployment exists and is available.
// Uses expectedLabels to find the deployment via label selector - if the list returns a deployment,
// it's guaranteed to have those labels (no need to verify them again).
func (h *Helper) VerifyDeploymentAvailable(ctx context.Context, namespace string, expectedLabels, expectedAnnotations map[string]string) error {
    // Build label selector from expected labels to find the deployment
    labelSelector := labels.SelectorFromSet(expectedLabels).String()
    logger.Info("verifying deployment status", "namespace", namespace, "label_selector", labelSelector)

    // List deployments by label selector
    deployments, err := h.K8sClient.AppsV1().Deployments(namespace).List(ctx, metav1.ListOptions{
        LabelSelector: labelSelector,
    })
    if err != nil {
        if apierrors.IsNotFound(err) {
            return fmt.Errorf("no deployment found in namespace %s with selector %s", namespace, labelSelector)
        }
        return fmt.Errorf("failed to list deployments in namespace %s with selector %s: %w",
            namespace, labelSelector, err)
    }

    // Verify exactly one deployment
    if len(deployments.Items) == 0 {
        return fmt.Errorf("no deployment found in namespace %s with selector %s", namespace, labelSelector)
    }
    if len(deployments.Items) > 1 {
        return fmt.Errorf("multiple deployments (%d) found in namespace %s with selector %s - expected exactly one",
            len(deployments.Items), namespace, labelSelector)
    }

    deploy := deployments.Items[0]

    // Check availability using DeploymentAvailable condition (canonical way)
    var deployAvailable bool
    for _, cond := range deploy.Status.Conditions {
        if cond.Type == appsv1.DeploymentAvailable && cond.Status == corev1.ConditionTrue {
            deployAvailable = true
            break
        }
    }

    if !deployAvailable {
        return fmt.Errorf("deployment %s in namespace %s is not available (availableReplicas=%d, conditions: %+v)",
            deploy.Name, namespace, deploy.Status.AvailableReplicas, deploy.Status.Conditions)
    }

    // Verify annotations
    if err := verifyMapContains(deploy.Annotations, expectedAnnotations, "annotation"); err != nil {
        return fmt.Errorf("deployment %s in namespace %s: %w", deploy.Name, namespace, err)
    }

    logger.Info("deployment verified successfully",
        "namespace", namespace,
        "deployment", deploy.Name,
        "available_replicas", deploy.Status.AvailableReplicas)
    return nil
}

// verifyMapContains checks if actual map contains all expected key-value pairs
func verifyMapContains(actual, expected map[string]string, mapType string) error {
    missing := make([]string, 0, len(expected))
    mismatched := make([]string, 0, len(expected))

    for key, expectedValue := range expected {
        actualValue, exists := actual[key]
        if !exists {
            missing = append(missing, key)
            continue
        }

        if actualValue != expectedValue {
            mismatched = append(mismatched, fmt.Sprintf("%s (expected: %s, actual: %s)",
                key, expectedValue, actualValue))
        }
    }

    if len(missing) > 0 || len(mismatched) > 0 {
        var errParts []string
        if len(missing) > 0 {
            sort.Strings(missing)
            errParts = append(errParts, fmt.Sprintf("missing %ss: %s", mapType, strings.Join(missing, ", ")))
        }
        if len(mismatched) > 0 {
            sort.Strings(mismatched)
            errParts = append(errParts, fmt.Sprintf("mismatched %ss: %s", mapType, strings.Join(mismatched, "; ")))
        }
        return fmt.Errorf("%s", strings.Join(errParts, "; "))
    }

    return nil
}
